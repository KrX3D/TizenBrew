#!/usr/bin/expect -f

# Fail fast if packaging prompts for interactive input and never exits.
set timeout 240

if {[info exists env(APP_PATH)] == 0 || [info exists env(CERT)] == 0} {
    puts "Missing required env vars APP_PATH or CERT"
    exit 1
}

set password ""
if {[info exists env(PASSWORD)] && $env(PASSWORD) ne ""} {
    set password $env(PASSWORD)
} elseif {[info exists env(TIZEN_AUTHOR_KEY_PW)] && $env(TIZEN_AUTHOR_KEY_PW) ne ""} {
    # Backward-compatible fallback if workflow exports the secret under its raw name.
    set password $env(TIZEN_AUTHOR_KEY_PW)
}

cd $env(APP_PATH)

set cmd "/home/runner/work/TizenBrew/TizenBrew/tizen-studio/tools/ide/bin/tizen package -t wgt -o ./release -s $env(CERT) -- .buildResult"
puts "Running: $cmd"
spawn {*}[split $cmd " "]

expect {
    # Handle save-password confirmation first so it is not confused with password prompts.
    -nocase -re {save author password} {
        send -- "y\r"
        exp_continue
    }
    -nocase -re {yes:\s*\(y\),\s*no:\s*\(n\)\s*\?.*} {
        send -- "y\r"
        exp_continue
    }
    # Keep password matches line-bounded so they do not consume the Yes/No prompt.
    -nocase "*author password:*" {
        if {$password eq ""} {
            puts "Author password requested but PASSWORD env var is empty"
            exit 1
        }
        send -- "$password\r"
        exp_continue
    }
    -nocase "*password:*" {
        if {$password eq ""} {
            puts "Password requested but PASSWORD env var is empty"
            exit 1
        }
        send -- "$password\r"
        exp_continue
    }
    -nocase -re {continue\?.*} {
        send -- "y\r"
        exp_continue
    }
    timeout {
        puts "Timed out waiting for tizen package to finish"
        catch {exec pkill -f "tizen package -t wgt"}
        exit 1
    }
    eof
}

# propagate child exit code
catch wait result
set exit_code [lindex $result 3]
exit $exit_code
